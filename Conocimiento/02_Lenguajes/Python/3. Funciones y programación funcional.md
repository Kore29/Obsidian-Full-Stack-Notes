#python #lenguajes

## Funciones como ciudadanos de primera clase

En Python, **las funciones son objetos de primera clase**. Esto significa que puedes:

- Asignar una funci贸n a una variable.
- Pasar una funci贸n como argumento a otra.
- Devolver una funci贸n desde otra funci贸n.
- Almacenar funciones en estructuras de datos.

Ejemplo b谩sico:

```python
def saludar(nombre):
    return f"Hola, {nombre}"

func = saludar  # Asignamos la funci贸n a una variable
print(func("Ana"))  # Llamamos usando la variable
```

Esto es similar a lo que ocurre en JavaScript, pero distinto de Java (donde hay que usar interfaces funcionales o lambdas).

## Lambdas: limitaciones y usos comunes

Python soporta funciones an贸nimas con `lambda`, pero **solo pueden contener una 煤nica expresi贸n**.

Ejemplo:

```python
doble = lambda x: x * 2
print(doble(5))  # 10
```

A diferencia de otros lenguajes como JavaScript o Java (con lambdas), no puedes incluir m煤ltiples l铆neas ni sentencias complejas.

Uso com煤n:
- Como argumentos en funciones como `map()`, `filter()` o `sorted()`.

```python
nombres = ["Ana", "Carlos", "Beto", "David"]
ordenados = sorted(nombres, key=lambda nombre: len(nombre))
```

 **Recomendaci贸n**: Usa `lambda` solo para operaciones simples y en l铆nea. Para l贸gica m谩s compleja, define una funci贸n normal.

## `map`, `filter`, `reduce` y alternativas modernas

Python ofrece herramientas b谩sicas de programaci贸n funcional:

#### `map()`
Aplica una funci贸n a cada elemento de un iterable.

```python
numeros = [1, 2, 3]
cuadrados = list(map(lambda x: x ** 2, numeros))
```

Alternativa moderna con list comprehension:

```python
cuadrados = [x ** 2 for x in numeros]
```

#### `filter()`
Filtra elementos seg煤n una condici贸n.

```python
pares = list(filter(lambda x: x % 2 == 0, numeros))
```

Con list comprehension:

```python
pares = [x for x in numeros if x % 2 == 0]
```

#### `reduce()`
Para reducir una secuencia a un solo valor. Debes importarlo:

```python
from functools import reduce

suma = reduce(lambda acc, x: acc + x, numeros)
```

No tiene un equivalente directo en comprehensions, pero 煤til para acumulaciones personalizadas.

 **Consejo r谩pido**: Las comprehensions suelen ser m谩s legibles y preferidas sobre `map` o `filter`.

### Argumentos posicionales, por nombre, `*args`, `**kwargs`

Python permite mucha flexibilidad al definir funciones:

```python
def ejemplo(a, b, *args, c=5, d=10, **kwargs):
    print(f"a={a}, b={b}, args={args}, c={c}, d={d}, kwargs={kwargs}")
```

Llamada:

```python
ejemplo(1, 2, 3, 4, c=9, extra="hola")
# a=1, b=2, args=(3, 4), c=9, d=10, kwargs={'extra': 'hola'}
```

Explicaci贸n:
- `*args`: captura argumentos posicionales adicionales.
- `**kwargs`: captura argumentos nombrados adicionales.

Este nivel de flexibilidad no existe igual en muchos otros lenguajes, donde debes especificar cantidad y tipo de par谩metros.

## Decoradores: qu茅 son y c贸mo funcionan internamente

Los decoradores son **funciones que modifican otras funciones sin cambiar su c贸digo**.

Ejemplo simple:

```python
def mi_decorador(func):
    def envoltorio(*args, **kwargs):
        print("Antes de ejecutar")
        resultado = func(*args, **kwargs)
        print("Despu茅s de ejecutar")
        return resultado
    return envoltorio

@mi_decorador
def saluda(nombre):
    print(f"Hola, {nombre}")

saluda("Pepe")
```

Equivalente a:

```python
saluda = mi_decorador(saluda)
saluda("Pepe")
```

Puedes encadenarlos:

```python
@decorador1
@decorador2
def funcion():
    pass
```

Es como hacer: `funcion = decorador1(decorador2(funcion))`

Uso com煤n:
- Logging
- Autenticaci贸n
- Medici贸n de tiempos

 **Importante**: Aseg煤rate de usar `functools.wraps` si est谩s creando decoradores reutilizables para preservar metadatos de la funci贸n original.

## Funciones anidadas y clausuras

Python permite definir funciones dentro de otras funciones:

```python
def exterior(x):
    def interior(y):
        return x + y
    return interior

sumar_5 = exterior(5)
print(sumar_5(3))  # 8
```

Aqu铆 `interior` es una **clausura (closure)**: recuerda los valores del 谩mbito superior incluso despu茅s de que la funci贸n exterior haya terminado.

Este patr贸n es muy usado para crear funciones configurables o factor铆as de funciones.

---
